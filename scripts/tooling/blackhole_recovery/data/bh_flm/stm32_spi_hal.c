/*
 * Copyright (c) 2025 Tenstorrent AI ULC
 * SPDX-License-Identifier: Apache-2.0
 */

#include "spi_hal.h"
#include "stm32g0xx_ll_gpio.h"
#include "stm32g0xx.h"
#include "stm32g0xx_ll_system.h"
#include "stm32g0xx_ll_rcc.h"
#include "stm32g0xx_ll_bus.h"
#include "stm32g0xx_ll_utils.h"
#include "stm32g0xx_ll_spi.h"

/*
 * This file implements the HAL interface for the STM32 SPI peripheral.
 * It includes initialization, deinit and data transfer functions.
 */

/*
 * Note that GCC has some *fun* restrictions when compiling for Cortex-M0+, namely
 * that PLT tables are not supported. This means that we effectively can't call
 * functions in other files directly, only via function pointer.
 * To keep things simple, this implementation is just baremetal.
 */

/* Generated by STM32CubeMX */
static void SystemClock_Config(void)
{
	LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
	while (LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2) {
	}

	/* HSI configuration and activation */
	LL_RCC_HSI_Enable();
	while (LL_RCC_HSI_IsReady() != 1) {
	}

	/* Main PLL configuration and activation */
	LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, LL_RCC_PLLM_DIV_1, 8, LL_RCC_PLLR_DIV_2);
	LL_RCC_PLL_Enable();
	LL_RCC_PLL_EnableDomain_SYS();
	while (LL_RCC_PLL_IsReady() != 1) {
	}

	/* Set AHB prescaler*/
	LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);

	/* Sysclk activation on the main PLL */
	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
	}

	/* Set APB1 prescaler*/
	LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
	/* Configure the SysTick to have interrupt in 1ms time base */
	SysTick->LOAD = (uint32_t)((64000) - 1UL); /* set reload register */
	SysTick->VAL = 0UL;                        /* Load the SysTick Counter Value */
	SysTick->CTRL =
		SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk; /* Enable the Systick Timer */
}

static void MX_GPIO_Init(void)
{
	/* USER CODE BEGIN MX_GPIO_Init_1 */

	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOB);
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOC);

	/**/
	LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_7);

	/**/
	LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_5);

	/* PA4- NSS */
	LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_4, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_4, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOA, LL_GPIO_PIN_4, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_4, LL_GPIO_PULL_UP);
	LL_GPIO_SetAFPin_0_7(GPIOA, LL_GPIO_PIN_4, LL_GPIO_AF_0);

	/* PC7- SPI RST */
	LL_GPIO_SetPinMode(GPIOC, LL_GPIO_PIN_7, LL_GPIO_MODE_OUTPUT);
	LL_GPIO_SetPinSpeed(GPIOC, LL_GPIO_PIN_7, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOC, LL_GPIO_PIN_7, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOC, LL_GPIO_PIN_7, LL_GPIO_PULL_NO);

	/* PA11- MISO */
	LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_11, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_11, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOA, LL_GPIO_PIN_11, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_11, LL_GPIO_PULL_DOWN);
	LL_GPIO_SetAFPin_8_15(GPIOA, LL_GPIO_PIN_11, LL_GPIO_AF_0);

	/* PA12- MOSI */
	LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_12, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_12, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOA, LL_GPIO_PIN_12, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_12, LL_GPIO_PULL_DOWN);
	LL_GPIO_SetAFPin_8_15(GPIOA, LL_GPIO_PIN_12, LL_GPIO_AF_0);

	/* PB3- SCK */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_3, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_3, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_3, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_3, LL_GPIO_PULL_UP);
	LL_GPIO_SetAFPin_0_7(GPIOB, LL_GPIO_PIN_3, LL_GPIO_AF_0);

	/* PB5- SPI MUX */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_5, LL_GPIO_MODE_OUTPUT);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_5, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_5, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_5, LL_GPIO_PULL_NO);

	/* USER CODE BEGIN MX_GPIO_Init_2 */

	/* USER CODE END MX_GPIO_Init_2 */
}

/**
 * @brief  This function provides accurate delay (in milliseconds) based
 *         on SysTick counter flag
 * @note   When a RTOS is used, it is recommended to avoid using blocking delay
 *         and use rather osDelay service.
 * @note   To respect 1ms timebase, user should call @ref LL_Init1msTick function which
 *         will configure Systick to 1ms
 * @param  Delay specifies the delay time length, in milliseconds.
 * @retval None
 */
void LL_mDelay(uint32_t Delay)
{
	__IO uint32_t tmp = SysTick->CTRL; /* Clear the COUNTFLAG first */
	uint32_t tmpDelay;                 /* MISRAC2012-Rule-17.8 */
	/* Add this code to indicate that local variable is not used */
	((void)tmp);
	tmpDelay = Delay;
	/* Add a period to guaranty minimum wait */
	if (tmpDelay < LL_MAX_DELAY) {
		tmpDelay++;
	}

	while (tmpDelay != 0U) {
		if ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U) {
			tmpDelay--;
		}
	}
}

/*
 * Init the SPI peripheral, including setting up GPIOs and clocks.
 * @return 0 on success, -1 on failure.
 */
int stm32_spi_init(void)
{
	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);
	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);
	LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI1);
	LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI1);

	/** Disable the internal Pull-Up in Dead Battery pins of UCPD peripheral */
	LL_SYSCFG_DisableDBATT(LL_SYSCFG_UCPD1_STROBE | LL_SYSCFG_UCPD2_STROBE);
	/* Setup system clock */
	SystemClock_Config();
	/* Initialize GPIOs */
	MX_GPIO_Init();

	/* Peripheral clock enable */
	LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SPI1);
	/*
	 * System core clock (and PCLK) are running at 64 MHz.
	 * Clock SPI at 8 MHz.
	 */
	LL_SPI_SetTransferDirection(SPI1, LL_SPI_FULL_DUPLEX);
	LL_SPI_SetMode(SPI1, LL_SPI_MODE_MASTER);
	LL_SPI_SetDataWidth(SPI1, LL_SPI_DATAWIDTH_8BIT);
	LL_SPI_SetClockPolarity(SPI1, LL_SPI_POLARITY_HIGH);
	LL_SPI_SetClockPhase(SPI1, LL_SPI_PHASE_2EDGE);
	LL_SPI_SetNSSMode(SPI1, LL_SPI_NSS_HARD_OUTPUT);
	LL_SPI_SetBaudRatePrescaler(SPI1, LL_SPI_BAUDRATEPRESCALER_DIV16);
	LL_SPI_SetTransferBitOrder(SPI1, LL_SPI_MSB_FIRST);
	LL_SPI_DisableCRC(SPI1);
	LL_SPI_SetStandard(SPI1, LL_SPI_PROTOCOL_MOTOROLA);
	LL_SPI_DisableNSSPulseMgt(SPI1);
	/* Set RX FIFO level to 8 bits (1/4) */
	LL_SPI_SetRxFIFOThreshold(SPI1, LL_SPI_RX_FIFO_TH_QUARTER);
	/* Disable interrupts */
	LL_SPI_DisableIT_ERR(SPI1);
	LL_SPI_DisableIT_RXNE(SPI1);
	LL_SPI_DisableIT_TXE(SPI1);
	/* Disable DMA */
	LL_SPI_DisableDMAReq_RX(SPI1);
	LL_SPI_DisableDMAReq_TX(SPI1);

	/* Set SPI MUX to high so we have control over the SPI pins */
	LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_5);

	/* Pulse RST line to reset SPI */
	LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_7);
	LL_mDelay(1); /* Wait for 1 ms */
	LL_GPIO_SetOutputPin(GPIOC, LL_GPIO_PIN_7);
	return 0;
}

/*
 * Deinitialize the SPI peripheral.
 * @return 0 on success, -1 on failure.
 */
int stm32_spi_deinit(void)
{
	/* Force reset of SPI clock */
	LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI1);
	/* Release reset of SPI clock */
	LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI1);
	return 0;
}

/*
 * Transfer data over SPI.
 * @param bufs: Array of buffers containing data to transmit and receive.
 * @param cnt: Number of buffers in the array.
 * @return 0 on success, -1 on failure.
 */
int stm32_spi_transfer(struct spi_buf *bufs, uint8_t cnt)
{
	uint32_t tx_off, rx_off;

	LL_SPI_Enable(SPI1);
	/* Just use a polling transfer here */
	for (uint8_t buf_idx = 0; buf_idx < cnt; buf_idx++) {
		tx_off = 0, rx_off = 0;
		while (tx_off < bufs[buf_idx].len || rx_off < bufs[buf_idx].len) {
			if (LL_SPI_IsActiveFlag_TXE(SPI1) && tx_off < bufs[buf_idx].len) {
				/* Write bytes to TX FIFO */
				if (bufs[buf_idx].tx_buf) {
					LL_SPI_TransmitData8(SPI1, bufs[buf_idx].tx_buf[tx_off]);
				} else {
					LL_SPI_TransmitData8(SPI1,
							     0xFF); /* If no TX buffer, send 0xFF */
				}
				tx_off++;
			}
			if (LL_SPI_IsActiveFlag_RXNE(SPI1) && rx_off < bufs[buf_idx].len) {
				/* Read bytes from RX FIFO */
				if (bufs[buf_idx].rx_buf) {
					bufs[buf_idx].rx_buf[rx_off] = LL_SPI_ReceiveData8(SPI1);
				} else {
					LL_SPI_ReceiveData8(
						SPI1); /* If no RX buffer, discard data */
				}
				rx_off++;
			}
		}
	}

	while (LL_SPI_IsActiveFlag_BSY(SPI1)) {
		/* Wait for BSY flag to clear, indicating transfer is done. */
	}
	LL_SPI_Disable(SPI1);
	return 0;
}
