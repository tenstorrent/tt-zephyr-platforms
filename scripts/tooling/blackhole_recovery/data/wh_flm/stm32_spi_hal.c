/*
 * Copyright (c) 2025 Tenstorrent AI ULC
 * SPDX-License-Identifier: Apache-2.0
 */

#include "spi_hal.h"
#include "stm32g0xx_ll_gpio.h"
#include "stm32g0xx.h"
#include "stm32g0xx_ll_system.h"
#include "stm32g0xx_ll_rcc.h"
#include "stm32g0xx_ll_bus.h"
#include "stm32g0xx_ll_utils.h"
#include "stm32g0xx_ll_spi.h"

/*
 * This file implements the HAL interface for the STM32 SPI peripheral.
 * It includes initialization, deinit and data transfer functions.
 */

/*
 * Note that GCC has some *fun* restrictions when compiling for Cortex-M0+, namely
 * that PLT tables are not supported. This means that we effectively can't call
 * functions in other files directly, only via function pointer.
 * To keep things simple, this implementation is just baremetal.
 */

/* Generated by STM32CubeMX */
static void SystemClock_Config(void)
{
	LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
	while (LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2) {
	}

	/* HSI configuration and activation */
	LL_RCC_HSI_Enable();
	while (LL_RCC_HSI_IsReady() != 1) {
	}

	/* Main PLL configuration and activation */
	LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, LL_RCC_PLLM_DIV_1, 8, LL_RCC_PLLR_DIV_2);
	LL_RCC_PLL_Enable();
	LL_RCC_PLL_EnableDomain_SYS();
	while (LL_RCC_PLL_IsReady() != 1) {
	}

	/* Set AHB prescaler*/
	LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);

	/* Sysclk activation on the main PLL */
	LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
	while (LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {
	}

	/* Set APB1 prescaler*/
	LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
	/* Configure the SysTick to have interrupt in 1ms time base */
	SysTick->LOAD = (uint32_t)((64000) - 1UL); /* set reload register */
	SysTick->VAL = 0UL;                        /* Load the SysTick Counter Value */
	SysTick->CTRL =
		SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk; /* Enable the Systick Timer */
}

/*
 * USE_SPI1: RIGHT_M3_SPI_INTERFACE on STM32G031
 * Uses SPI1 peripheral:
 * - PA15: SPI1_NSS (AF0)
 * - PB3: SPI1_SCK (AF0)
 * - PB4: SPI1_MISO (AF0)
 * - PA12: SPI1_MOSI (AF0)
 * - PA11: SPI MUX (GPIO output)
 */
#ifdef USE_SPI1
static void SPI1_GPIO_INIT(void)
{
	/* GPIO Ports Clock Enable */
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOB);

    // LL_GPIO_ResetOutputPin(GPIOC, LL_GPIO_PIN_7);

	/* PA15- SPI1_NSS */
	LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_15);
	LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_15, LL_GPIO_MODE_OUTPUT);
	LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_15, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOA, LL_GPIO_PIN_15, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_15, LL_GPIO_PULL_NO);

	// LL_GPIO_ResetOutputPin(GPIOB, LL_GPIO_PIN_5);
	/* PB3- SPI1_SCK */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_3, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_3, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_3, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_3, LL_GPIO_PULL_UP);
	LL_GPIO_SetAFPin_0_7(GPIOB, LL_GPIO_PIN_3, LL_GPIO_AF_0);

	/* PB4- SPI1_MISO */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_4, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_4, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_4, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_4, LL_GPIO_PULL_DOWN);
	LL_GPIO_SetAFPin_0_7(GPIOB, LL_GPIO_PIN_4, LL_GPIO_AF_0);

	/* PA12- SPI1_MOSI */
	LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_12, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_12, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOA, LL_GPIO_PIN_12, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_12, LL_GPIO_PULL_DOWN);
	LL_GPIO_SetAFPin_8_15(GPIOA, LL_GPIO_PIN_12, LL_GPIO_AF_0);

	/* PA11- SPI MUX (output, directly controlled) */
	LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_11, LL_GPIO_MODE_OUTPUT);
	LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_11, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOA, LL_GPIO_PIN_11, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_11, LL_GPIO_PULL_NO);
}
#endif

/*
 * USE_SPI2: LEFT_M3_SPI_INTERFACE on STM32G031
 * Uses SPI2 peripheral:
 * - PB12: SPI2_NSS (AF0)
 * - PB13: SPI2_SCK (AF0)
 * - PB14: SPI2_MISO (AF0)
 * - PB15: SPI2_MOSI (AF0)
 * - PA8: SPI MUX (GPIO output)
 */
#ifdef USE_SPI2
static void SPI2_GPIO_INIT(void)
{
	/* GPIO Ports Clock Enable */
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);
	LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOB);

	/* PB12- SPI2_NSS */
	LL_GPIO_SetOutputPin(GPIOB, LL_GPIO_PIN_12);
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_12, LL_GPIO_MODE_OUTPUT);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_12, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_12, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_12, LL_GPIO_PULL_NO);

	/* PB13- SPI2_SCK */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_13, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_13, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_13, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_13, LL_GPIO_PULL_UP);
	LL_GPIO_SetAFPin_8_15(GPIOB, LL_GPIO_PIN_13, LL_GPIO_AF_0);

	/* PB14- SPI2_MISO */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_14, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_14, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_14, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_14, LL_GPIO_PULL_DOWN);
	LL_GPIO_SetAFPin_8_15(GPIOB, LL_GPIO_PIN_14, LL_GPIO_AF_0);

	/* PB15- SPI2_MOSI */
	LL_GPIO_SetPinMode(GPIOB, LL_GPIO_PIN_15, LL_GPIO_MODE_ALTERNATE);
	LL_GPIO_SetPinSpeed(GPIOB, LL_GPIO_PIN_15, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOB, LL_GPIO_PIN_15, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOB, LL_GPIO_PIN_15, LL_GPIO_PULL_DOWN);
	LL_GPIO_SetAFPin_8_15(GPIOB, LL_GPIO_PIN_15, LL_GPIO_AF_0);

	/* PA8- SPI MUX (output, directly controlled) */
	LL_GPIO_SetPinMode(GPIOA, LL_GPIO_PIN_8, LL_GPIO_MODE_OUTPUT);
	LL_GPIO_SetPinSpeed(GPIOA, LL_GPIO_PIN_8, LL_GPIO_SPEED_FREQ_LOW);
	LL_GPIO_SetPinOutputType(GPIOA, LL_GPIO_PIN_8, LL_GPIO_OUTPUT_PUSHPULL);
	LL_GPIO_SetPinPull(GPIOA, LL_GPIO_PIN_8, LL_GPIO_PULL_NO);
}
#endif

/**
 * @brief  This function provides accurate delay (in milliseconds) based
 *         on SysTick counter flag
 * @note   When a RTOS is used, it is recommended to avoid using blocking delay
 *         and use rather osDelay service.
 * @note   To respect 1ms timebase, user should call @ref LL_Init1msTick function which
 *         will configure Systick to 1ms
 * @param  Delay specifies the delay time length, in milliseconds.
 * @retval None
 */
void LL_mDelay(uint32_t Delay)
{
	__IO uint32_t tmp = SysTick->CTRL; /* Clear the COUNTFLAG first */
	uint32_t tmpDelay;                 /* MISRAC2012-Rule-17.8 */
	/* Add this code to indicate that local variable is not used */
	((void)tmp);
	tmpDelay = Delay;
	/* Add a period to guaranty minimum wait */
	if (tmpDelay < LL_MAX_DELAY) {
		tmpDelay++;
	}

	while (tmpDelay != 0U) {
		if ((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) != 0U) {
			tmpDelay--;
		}
	}
}

void stm32_spi_periph_init(SPI_TypeDef *spi)
{
	/*
	 * System core clock (and PCLK) are running at 64 MHz.
	 * Clock SPI at 8 MHz.
	 */
	LL_SPI_SetTransferDirection(spi, LL_SPI_FULL_DUPLEX);
	LL_SPI_SetMode(spi, LL_SPI_MODE_MASTER);
	LL_SPI_SetDataWidth(spi, LL_SPI_DATAWIDTH_8BIT);
	LL_SPI_SetClockPolarity(spi, LL_SPI_POLARITY_HIGH);
	LL_SPI_SetClockPhase(spi, LL_SPI_PHASE_2EDGE);
	/* Software NSS */
	LL_SPI_SetNSSMode(spi, LL_SPI_NSS_SOFT);
	SET_BIT(spi->CR1, SPI_CR1_SSI);
	/* 8 MHz works fine for general use */
	LL_SPI_SetBaudRatePrescaler(spi, LL_SPI_BAUDRATEPRESCALER_DIV16);
	LL_SPI_SetTransferBitOrder(spi, LL_SPI_MSB_FIRST);
	LL_SPI_DisableCRC(spi);
	LL_SPI_SetStandard(spi, LL_SPI_PROTOCOL_MOTOROLA);
	/* Set RX FIFO level to 8 bits (1/4) */
	LL_SPI_SetRxFIFOThreshold(spi, LL_SPI_RX_FIFO_TH_QUARTER);
	/* Disable interrupts */
	LL_SPI_DisableIT_ERR(spi);
	LL_SPI_DisableIT_RXNE(spi);
	LL_SPI_DisableIT_TXE(spi);
	/* Disable DMA */
	LL_SPI_DisableDMAReq_RX(spi);
	LL_SPI_DisableDMAReq_TX(spi);
}

/*
 * Init the SPI peripheral, including setting up GPIOs and clocks.
 * @return 0 on success, -1 on failure.
 */
int stm32_spi_init(void)
{
	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);
	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);

	/* Setup system clock */
	SystemClock_Config();

	/* Peripheral clock enable */
#ifdef USE_SPI1
	/* USE_SPI1: RIGHT_M3_SPI_INTERFACE */
	LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SPI1);
	LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI1);
	LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI1);
	/* Initialize GPIOs */
	SPI1_GPIO_INIT();
	stm32_spi_periph_init(SPI1);

	/* Set SPI MUX to high so we have control over the SPI pins */
	LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_11);
#elif defined(USE_SPI2)
	/* USE_SPI2: LEFT_M3_SPI_INTERFACE */
	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_SPI2);
	LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_SPI2);
	LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_SPI2);
	/* Initialize GPIOs */
	SPI2_GPIO_INIT();
	stm32_spi_periph_init(SPI2);

	/* Set SPI MUX to high so we have control over the SPI pins */
	LL_GPIO_SetOutputPin(GPIOA, LL_GPIO_PIN_8);
#endif
	return 0;
}

/*
 * Deinitialize the SPI peripheral.
 * @return 0 on success, -1 on failure.
 */
int stm32_spi_deinit(void)
{
#ifdef USE_SPI1
	LL_APB2_GRP1_ForceReset(LL_APB2_GRP1_PERIPH_SPI1);
	LL_APB2_GRP1_ReleaseReset(LL_APB2_GRP1_PERIPH_SPI1);
#elif defined(USE_SPI2)
	LL_APB1_GRP1_ForceReset(LL_APB1_GRP1_PERIPH_SPI2);
	LL_APB1_GRP1_ReleaseReset(LL_APB1_GRP1_PERIPH_SPI2);
#endif
	return 0;
}

#ifdef USE_SPI1
#define SPI_DEV  SPI1
#define NSS_PORT GPIOA
#define NSS_PIN  LL_GPIO_PIN_15
#elif defined(USE_SPI2)
#define SPI_DEV  SPI2
#define NSS_PORT GPIOB
#define NSS_PIN  LL_GPIO_PIN_12
#endif

/*
 * Transfer data over SPI.
 * @param bufs: Array of buffers containing data to transmit and receive.
 * @param cnt: Number of buffers in the array.
 * @return 0 on success, -1 on failure.
 */
int stm32_spi_transfer(struct spi_buf *bufs, uint8_t cnt)
{
	uint32_t tx_off, rx_off;

	LL_GPIO_ResetOutputPin(NSS_PORT, NSS_PIN);
	LL_SPI_Enable(SPI_DEV);

	/* Just use a polling transfer here */
	for (uint8_t buf_idx = 0; buf_idx < cnt; buf_idx++) {
		tx_off = 0, rx_off = 0;
		while (tx_off < bufs[buf_idx].len || rx_off < bufs[buf_idx].len) {
			if (LL_SPI_IsActiveFlag_TXE(SPI_DEV) && tx_off < bufs[buf_idx].len) {
				/* Write bytes to TX FIFO */
				if (bufs[buf_idx].tx_buf) {
					LL_SPI_TransmitData8(SPI_DEV, bufs[buf_idx].tx_buf[tx_off]);
				} else {
					LL_SPI_TransmitData8(SPI_DEV,
							     0xFF); /* If no TX buffer, send 0xFF */
				}
				tx_off++;
			}
			if (LL_SPI_IsActiveFlag_RXNE(SPI_DEV) && rx_off < bufs[buf_idx].len) {
				/* Read bytes from RX FIFO */
				if (bufs[buf_idx].rx_buf) {
					bufs[buf_idx].rx_buf[rx_off] = LL_SPI_ReceiveData8(SPI_DEV);
				} else {
					LL_SPI_ReceiveData8(
						SPI_DEV); /* If no RX buffer, discard data */
				}
				rx_off++;
			}
		}
	}

	while (LL_SPI_IsActiveFlag_BSY(SPI_DEV)) {
		/* Wait for BSY flag to clear, indicating transfer is done. */
	}
	LL_SPI_Disable(SPI_DEV);

	LL_GPIO_SetOutputPin(NSS_PORT, NSS_PIN);
	return 0;
}
