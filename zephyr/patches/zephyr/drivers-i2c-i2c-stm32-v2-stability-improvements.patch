From 21783023e108e7cdb25cf5730827ae00144c430f Mon Sep 17 00:00:00 2001
From: Erik Andersson <erian747@gmail.com>
Date: Thu, 3 Jul 2025 05:59:32 +0200
Subject: [PATCH 1/7] drivers: i2c_stm32_v2: Add DMA helpers

To prepare for further patches and separation
of interrupt/DMA modes from polled, this commit
introduces two helpers for starting and stopping
DMA transfers

Signed-off-by: Erik Andersson <erian747@gmail.com>
---
 drivers/i2c/i2c_ll_stm32_v2.c | 137 +++++++++++++++++-----------------
 1 file changed, 70 insertions(+), 67 deletions(-)

diff --git a/drivers/i2c/i2c_ll_stm32_v2.c b/drivers/i2c/i2c_ll_stm32_v2.c
index 41a14897119d4..48c846d80e4ff 100644
--- a/drivers/i2c/i2c_ll_stm32_v2.c
+++ b/drivers/i2c/i2c_ll_stm32_v2.c
@@ -19,7 +19,7 @@
 #include <zephyr/drivers/i2c.h>
 #include <zephyr/pm/device.h>
 #include <zephyr/pm/device_runtime.h>
-
+#include <stm32_cache.h>
 #include <zephyr/cache.h>
 #include <zephyr/linker/linker-defs.h>
 #include <zephyr/mem_mgmt/mem_attr.h>
@@ -150,6 +150,68 @@ static int configure_dma(struct stream const *dma, struct dma_config *dma_cfg,
 
 	return 0;
 }
+
+static void dma_xfer_start(const struct device *dev, struct i2c_msg *msg)
+{
+	const struct i2c_stm32_config *cfg = dev->config;
+	struct i2c_stm32_data *data = dev->data;
+	I2C_TypeDef *i2c = cfg->i2c;
+
+	if ((msg->flags & I2C_MSG_READ) != 0U) {
+		/* Configure RX DMA */
+		data->dma_blk_cfg.source_address = LL_I2C_DMA_GetRegAddr(
+			cfg->i2c, LL_I2C_DMA_REG_DATA_RECEIVE);
+		data->dma_blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
+		data->dma_blk_cfg.dest_address = (uint32_t)data->current.buf;
+		data->dma_blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
+		data->dma_blk_cfg.block_size = data->current.len;
+
+		if (configure_dma(&cfg->rx_dma, &data->dma_rx_cfg,
+					&data->dma_blk_cfg) != 0) {
+			LOG_ERR("Problem setting up RX DMA");
+			return;
+		}
+		data->current.buf += msg->len;
+		data->current.len -= msg->len;
+		LL_I2C_EnableDMAReq_RX(i2c);
+	} else {
+		if (data->current.len != 0U) {
+			/* Configure TX DMA */
+			data->dma_blk_cfg.source_address = (uint32_t)data->current.buf;
+			data->dma_blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
+			data->dma_blk_cfg.dest_address = LL_I2C_DMA_GetRegAddr(
+				cfg->i2c, LL_I2C_DMA_REG_DATA_TRANSMIT);
+			data->dma_blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
+			data->dma_blk_cfg.block_size = data->current.len;
+
+			if (configure_dma(&cfg->tx_dma, &data->dma_tx_cfg,
+						&data->dma_blk_cfg) != 0) {
+				LOG_ERR("Problem setting up TX DMA");
+				return;
+			}
+			data->current.buf += data->current.len;
+			data->current.len -= data->current.len;
+			LL_I2C_EnableDMAReq_TX(i2c);
+		}
+	}
+}
+
+static void dma_finish(const struct device *dev, struct i2c_msg *msg)
+{
+	const struct i2c_stm32_config *cfg = dev->config;
+
+	if ((msg->flags & I2C_MSG_READ) != 0U) {
+		dma_stop(cfg->rx_dma.dev_dma, cfg->rx_dma.dma_channel);
+		LL_I2C_DisableDMAReq_RX(cfg->i2c);
+		if (!stm32_buf_in_nocache((uintptr_t)msg->buf, msg->len)) {
+			sys_cache_data_invd_range(msg->buf, msg->len);
+		}
+	} else {
+		dma_stop(cfg->tx_dma.dev_dma, cfg->tx_dma.dma_channel);
+		LL_I2C_DisableDMAReq_TX(cfg->i2c);
+	}
+}
+
 #endif /* CONFIG_I2C_STM32_V2_DMA */
 
 static inline void msg_init(const struct device *dev, struct i2c_msg *msg,
@@ -189,44 +251,7 @@ static inline void msg_init(const struct device *dev, struct i2c_msg *msg,
 
 #ifdef CONFIG_I2C_STM32_V2_DMA
 		if (msg->len) {
-			if (msg->flags & I2C_MSG_READ) {
-				/* Configure RX DMA */
-				data->dma_blk_cfg.source_address = LL_I2C_DMA_GetRegAddr(
-					cfg->i2c, LL_I2C_DMA_REG_DATA_RECEIVE);
-				data->dma_blk_cfg.source_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
-				data->dma_blk_cfg.dest_address = (uint32_t)msg->buf;
-				data->dma_blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
-				data->dma_blk_cfg.block_size = msg->len;
-
-				if (configure_dma(&cfg->rx_dma, &data->dma_rx_cfg,
-						  &data->dma_blk_cfg) != 0) {
-					LOG_ERR("Problem setting up RX DMA");
-					return;
-				}
-				data->current.buf += msg->len;
-				data->current.len -= msg->len;
-				LL_I2C_EnableDMAReq_RX(i2c);
-			} else {
-				if (data->current.len) {
-					/* Configure TX DMA */
-					data->dma_blk_cfg.source_address =
-						(uint32_t)data->current.buf;
-					data->dma_blk_cfg.source_addr_adj = DMA_ADDR_ADJ_INCREMENT;
-					data->dma_blk_cfg.dest_address = LL_I2C_DMA_GetRegAddr(
-						cfg->i2c, LL_I2C_DMA_REG_DATA_TRANSMIT);
-					data->dma_blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
-					data->dma_blk_cfg.block_size = msg->len;
-
-					if (configure_dma(&cfg->tx_dma, &data->dma_tx_cfg,
-							  &data->dma_blk_cfg) != 0) {
-						LOG_ERR("Problem setting up TX DMA");
-						return;
-					}
-					data->current.buf += data->current.len;
-					data->current.len -= data->current.len;
-					LL_I2C_EnableDMAReq_TX(i2c);
-				}
-			}
+			dma_xfer_start(dev, msg);
 		}
 #endif /* CONFIG_I2C_STM32_V2_DMA */
 
@@ -289,16 +314,6 @@ static void i2c_stm32_master_mode_end(const struct device *dev)
 	}
 #endif
 
-#ifdef CONFIG_I2C_STM32_V2_DMA
-	if (data->current.msg->flags & I2C_MSG_READ) {
-		dma_stop(cfg->rx_dma.dev_dma, cfg->rx_dma.dma_channel);
-		LL_I2C_DisableDMAReq_RX(i2c);
-	} else {
-		dma_stop(cfg->tx_dma.dev_dma, cfg->tx_dma.dma_channel);
-		LL_I2C_DisableDMAReq_TX(i2c);
-	}
-#endif /* CONFIG_I2C_STM32_V2_DMA */
-
 	k_sem_give(&data->device_sync_sem);
 }
 
@@ -598,17 +613,6 @@ void i2c_stm32_event(const struct device *dev)
 			LL_I2C_GenerateStopCondition(i2c);
 		} else {
 			i2c_stm32_disable_transfer_interrupts(dev);
-
-#ifdef CONFIG_I2C_STM32_V2_DMA
-			if (data->current.msg->flags & I2C_MSG_READ) {
-				dma_stop(cfg->rx_dma.dev_dma, cfg->rx_dma.dma_channel);
-				LL_I2C_DisableDMAReq_RX(i2c);
-			} else {
-				dma_stop(cfg->tx_dma.dev_dma, cfg->tx_dma.dma_channel);
-				LL_I2C_DisableDMAReq_TX(i2c);
-			}
-#endif /* CONFIG_I2C_STM32_V2_DMA */
-
 			k_sem_give(&data->device_sync_sem);
 		}
 	}
@@ -693,6 +697,9 @@ static int i2c_stm32_msg_write(const struct device *dev, struct i2c_msg *msg,
 		k_sem_take(&data->device_sync_sem, K_FOREVER);
 		is_timeout = true;
 	}
+#ifdef CONFIG_I2C_STM32_V2_DMA
+	dma_finish(dev, msg);
+#endif
 
 	if (data->current.is_nack || data->current.is_err ||
 	    data->current.is_arlo || is_timeout) {
@@ -752,13 +759,9 @@ static int i2c_stm32_msg_read(const struct device *dev, struct i2c_msg *msg,
 		k_sem_take(&data->device_sync_sem, K_FOREVER);
 		is_timeout = true;
 	}
-#if defined(CONFIG_I2C_STM32_V2_DMA)
-	if (!stm32_buf_in_nocache((uintptr_t)msg->buf, msg->len)) {
-		LOG_DBG("Rx buffer at %p (len %zu) is in cached memory; invalidating cache",
-			msg->buf, msg->len);
-		sys_cache_data_invd_range((void *)msg->buf, msg->len);
-	}
-#endif /* CONFIG_I2C_STM32_V2_DMA */
+#ifdef CONFIG_I2C_STM32_V2_DMA
+	dma_finish(dev, msg);
+#endif
 
 	if (data->current.is_nack || data->current.is_err ||
 	    data->current.is_arlo || is_timeout) {

From 49682c49698594e70294b151779d67ba603c0fcc Mon Sep 17 00:00:00 2001
From: Erik Andersson <erian747@gmail.com>
Date: Sun, 4 May 2025 22:10:18 +0200
Subject: [PATCH 2/7] drivers: i2c_stm32_v2: Rework interrupt handler

- Rework transaction flow  to better match reference manual
and errata sheet for STM32 I2Cv2 peripheral
- Handle message transactions larger than 255 bytes in isr
- Combine stm32_i2c_msg_write and stm32_i2c_msg_read into
one common function stm32_i2c_irq_xfer when using interrupts

Signed-off-by: Erik Andersson <erian747@gmail.com>
---
 drivers/i2c/i2c_ll_stm32.h    |   1 +
 drivers/i2c/i2c_ll_stm32_v2.c | 335 +++++++++++++++++++++++++++++-----
 2 files changed, 287 insertions(+), 49 deletions(-)

diff --git a/drivers/i2c/i2c_ll_stm32.h b/drivers/i2c/i2c_ll_stm32.h
index b194bc5e8f6ca..2dfcea83af74e 100644
--- a/drivers/i2c/i2c_ll_stm32.h
+++ b/drivers/i2c/i2c_ll_stm32.h
@@ -110,6 +110,7 @@ struct i2c_stm32_data {
 		unsigned int is_arlo;
 		unsigned int is_nack;
 		unsigned int is_err;
+		bool continue_in_next;
 		struct i2c_msg *msg;
 		unsigned int len;
 		uint8_t *buf;
diff --git a/drivers/i2c/i2c_ll_stm32_v2.c b/drivers/i2c/i2c_ll_stm32_v2.c
index 48c846d80e4ff..dc895e925e94f 100644
--- a/drivers/i2c/i2c_ll_stm32_v2.c
+++ b/drivers/i2c/i2c_ll_stm32_v2.c
@@ -171,8 +171,6 @@ static void dma_xfer_start(const struct device *dev, struct i2c_msg *msg)
 			LOG_ERR("Problem setting up RX DMA");
 			return;
 		}
-		data->current.buf += msg->len;
-		data->current.len -= msg->len;
 		LL_I2C_EnableDMAReq_RX(i2c);
 	} else {
 		if (data->current.len != 0U) {
@@ -189,8 +187,6 @@ static void dma_xfer_start(const struct device *dev, struct i2c_msg *msg)
 				LOG_ERR("Problem setting up TX DMA");
 				return;
 			}
-			data->current.buf += data->current.len;
-			data->current.len -= data->current.len;
 			LL_I2C_EnableDMAReq_TX(i2c);
 		}
 	}
@@ -563,7 +559,8 @@ void i2c_stm32_event(const struct device *dev)
 {
 	const struct i2c_stm32_config *cfg = dev->config;
 	struct i2c_stm32_data *data = dev->data;
-	I2C_TypeDef *i2c = cfg->i2c;
+	I2C_TypeDef *regs = cfg->i2c;
+	uint32_t isr = LL_I2C_ReadReg(regs, ISR);
 
 #if defined(CONFIG_I2C_TARGET)
 	if (data->slave_attached && !data->master_active) {
@@ -571,55 +568,101 @@ void i2c_stm32_event(const struct device *dev)
 		return;
 	}
 #endif
-	if (data->current.len) {
-		/* Send next byte */
-		if (LL_I2C_IsActiveFlag_TXIS(i2c)) {
-			LL_I2C_TransmitData8(i2c, *data->current.buf);
-		}
+	/* NACK received, a STOP will automatically be sent */
+	if ((isr & I2C_ISR_NACKF) != 0U) {
+		LL_I2C_ClearFlag_NACK(regs);
+		data->current.is_nack = 1U;
+
+	} else if ((isr & I2C_ISR_STOPF) != 0U) {
+		/* STOP detected, either caused by automatic STOP after NACK or
+		 * by request below in transfer complete
+		 */
+		/* Acknowledge stop condition */
+		LL_I2C_ClearFlag_STOP(regs);
+		/* Flush I2C controller TX buffer */
+		LL_I2C_ClearFlag_TXE(regs);
+		goto irq_xfer_completed;
+
+	} else if ((isr & I2C_ISR_RXNE) != 0U) {
+		__ASSERT_NO_MSG(data->current.len != 0U);
+		*data->current.buf = LL_I2C_ReceiveData8(regs);
+		data->current.len--;
+		data->current.buf++;
+
+	} else if ((isr & I2C_ISR_TCR) != 0U) {
+		/* Transfer complete with reload flag set means more data shall be transferred
+		 * in same direction (No RESTART or STOP)
+		 */
+		uint32_t cr2 = LL_I2C_ReadReg(regs, CR2);
+#ifdef CONFIG_I2C_STM32_V2_DMA
+		/* Get number of bytes bytes transferred by DMA */
+		uint32_t xfer_len = (cr2 & I2C_CR2_NBYTES_Msk) >> I2C_CR2_NBYTES_Pos;
 
-		/* Receive next byte */
-		if (LL_I2C_IsActiveFlag_RXNE(i2c)) {
-			*data->current.buf = LL_I2C_ReceiveData8(i2c);
+		data->current.len -= xfer_len;
+		data->current.buf += xfer_len;
+#endif
+
+		if (data->current.len == 0U) {
+			/* In this state all data from current message is transferred
+			 * and that reload was used indicates that next message will
+			 * contain more data in the same direction
+			 * So keep reload turned on and let thread continue with next message
+			 */
+			goto irq_xfer_completed;
+		} else if (data->current.len > 255U) {
+			/* More data exceeding I2C controllers maximum single transfer length
+			 * remaining in current message
+			 * Keep RELOAD mode and set NBYTES to 255 again
+			 */
+			LL_I2C_WriteReg(regs, CR2, cr2);
+		} else {
+			/* Data for a single transfer remains in buffer, set its length and
+			 * - If more messages follow and transfer direction for next message is
+			 *   same, keep reload on
+			 * - If direction changes or current message is the last,
+			 *   end reload mode and wait for TC
+			 */
+			cr2 &= ~I2C_CR2_NBYTES_Msk;
+			cr2 |= data->current.len << I2C_CR2_NBYTES_Pos;
+			/* If no more message data remains to be sent in current direction */
+			if (!data->current.continue_in_next) {
+				/* Disable reload mode, expect I2C_ISR_TC next */
+				cr2 &= ~I2C_CR2_RELOAD;
+			}
+			LL_I2C_WriteReg(regs, CR2, cr2);
 		}
 
-		data->current.buf++;
+	} else if ((isr & I2C_ISR_TXIS) != 0U) {
+		__ASSERT_NO_MSG(data->current.len != 0U);
+		LL_I2C_TransmitData8(regs, *data->current.buf);
 		data->current.len--;
-	}
+		data->current.buf++;
 
-	/* NACK received */
-	if (LL_I2C_IsActiveFlag_NACK(i2c)) {
-		LL_I2C_ClearFlag_NACK(i2c);
-		data->current.is_nack = 1U;
-		/*
-		 * AutoEndMode is always disabled in master mode,
-		 * so send a stop condition manually
+	} else if ((isr & I2C_ISR_TC) != 0U) {
+		/* Transfer Complete, (I2C_ISR_TC is set) no reload this time so either do
+		 * stop now or restart in thread
 		 */
-		LL_I2C_GenerateStopCondition(i2c);
-		return;
-	}
 
-	/* STOP received */
-	if (LL_I2C_IsActiveFlag_STOP(i2c)) {
-		LL_I2C_ClearFlag_STOP(i2c);
-		LL_I2C_DisableReloadMode(i2c);
-		goto end;
-	}
-
-	/* Transfer Complete or Transfer Complete Reload */
-	if (LL_I2C_IsActiveFlag_TC(i2c) ||
-	    LL_I2C_IsActiveFlag_TCR(i2c)) {
-		/* Issue stop condition if necessary */
-		if (data->current.msg->flags & I2C_MSG_STOP) {
-			LL_I2C_GenerateStopCondition(i2c);
+		/* Send stop if flag set in message */
+		if ((data->current.msg->flags & I2C_MSG_STOP) != 0U) {
+			/* Setting STOP here will clear TC, expect I2C_ISR_STOPF next */
+			LL_I2C_GenerateStopCondition(regs);
 		} else {
-			i2c_stm32_disable_transfer_interrupts(dev);
-			k_sem_give(&data->device_sync_sem);
+			/* Keep TC set and handover to thread for restart */
+			goto irq_xfer_completed;
 		}
+	} else {
+		/* Should not happen */
+		__ASSERT_NO_MSG(0);
 	}
 
 	return;
-end:
-	i2c_stm32_master_mode_end(dev);
+
+irq_xfer_completed:
+	/* Disable IRQ:s involved in data transfer */
+	i2c_stm32_disable_transfer_interrupts(dev);
+	/* Wakeup thread */
+	k_sem_give(&data->device_sync_sem);
 }
 
 int i2c_stm32_error(const struct device *dev)
@@ -794,6 +837,198 @@ static int i2c_stm32_msg_read(const struct device *dev, struct i2c_msg *msg,
 	return -EIO;
 }
 
+static int stm32_i2c_irq_xfer(const struct device *dev, struct i2c_msg *msg,
+			      uint8_t *next_msg_flags, uint16_t slave)
+{
+	const struct i2c_stm32_config *cfg = dev->config;
+	struct i2c_stm32_data *data = dev->data;
+	I2C_TypeDef *regs = cfg->i2c;
+	bool is_timeout = false;
+
+	data->current.len = msg->len;
+	data->current.buf = msg->buf;
+	data->current.is_arlo = 0U;
+	data->current.is_nack = 0U;
+	data->current.is_err = 0U;
+	data->current.msg = msg;
+
+#if defined(CONFIG_I2C_TARGET)
+	data->master_active = true;
+#endif
+
+#if defined(CONFIG_I2C_STM32_V2_DMA)
+	if (!stm32_buf_in_nocache((uintptr_t)msg->buf, msg->len) &&
+	    ((msg->flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE)) {
+		sys_cache_data_flush_range(msg->buf, msg->len);
+	}
+#endif /* CONFIG_I2C_STM32_V2_DMA */
+
+	/* Flush TX register */
+	LL_I2C_ClearFlag_TXE(regs);
+
+	/* Enable I2C peripheral if not already done */
+	LL_I2C_Enable(regs);
+
+	uint32_t cr2 = LL_I2C_ReadReg(regs, CR2);
+	uint32_t isr = LL_I2C_ReadReg(regs, ISR);
+
+	/* Clear fields in CR2 which will be filled in later in function */
+	cr2 &= ~(I2C_CR2_RELOAD | I2C_CR2_AUTOEND | I2C_CR2_NBYTES_Msk | I2C_CR2_SADD_Msk);
+
+	if ((I2C_ADDR_10_BITS & data->dev_config) != 0U) {
+		cr2 |= (uint32_t)slave | I2C_CR2_ADD10;
+	} else {
+		cr2 |= (uint32_t)slave << 1;
+	}
+
+	/* If this is not a stop message and more messages follow without change of direction,
+	 * reload mode must be used during this transaction
+	 * also a helper variable is set to inform IRQ handler about that it should
+	 * keep reload mode turned on ready for next message
+	 */
+	if (((msg->flags & I2C_MSG_STOP) == 0U) && (next_msg_flags != NULL) &&
+	    ((*next_msg_flags & I2C_MSG_RESTART) == 0U)) {
+		cr2 |= I2C_CR2_RELOAD;
+		data->current.continue_in_next = true;
+	} else {
+		data->current.continue_in_next = false;
+	}
+
+	/* For messages larger than 255 bytes, transactions must be split in chunks
+	 * Use reload mode and let IRQ handler take care of jumping to next chunk
+	 */
+	if (msg->len > 255U) {
+		cr2 |= (255U << I2C_CR2_NBYTES_Pos) | I2C_CR2_RELOAD;
+	} else {
+		/* Whole message can be sent in one I2C HW transaction */
+		cr2 |= msg->len << I2C_CR2_NBYTES_Pos;
+	}
+
+	/* If a reload mode transfer is pending since last message then skip
+	 * checking for transfer complete or restart flag in message
+	 * Reload transfer will start right after writing new length
+	 * to CR2 below
+	 */
+	if ((isr & I2C_ISR_TCR) == 0U) {
+
+		/* As TCR is not set, expect TC to be set or that this is a (re)start message
+		 * - msg->flags contains I2C_MSG_RESTART (for first start) or
+		 * - TC in ISR register is set which happens when IRQ handler
+		 *   has finalized its transfer and is waiting for restart
+		 * For both cases, a new start condition shall be sent
+		 */
+		__ASSERT_NO_MSG(((isr & I2C_ISR_TC) != 0U) ||
+				((msg->flags & I2C_MSG_RESTART) != 0U));
+
+		if ((msg->flags & I2C_MSG_RW_MASK) == I2C_MSG_WRITE) {
+			cr2 &= ~I2C_CR2_RD_WRN;
+#ifndef CONFIG_I2C_STM32_V2_DMA
+			/* Prepare first byte in TX buffer before transfer start as a
+			 * workaround for errata: "Transmission stalled after first byte transfer"
+			 */
+			if (data->current.len > 0U) {
+				LL_I2C_TransmitData8(regs, *data->current.buf);
+				data->current.len--;
+				data->current.buf++;
+			}
+#endif
+
+		} else {
+			cr2 |= I2C_CR2_RD_WRN;
+		}
+		/* Issue (re)start condition */
+		cr2 |= I2C_CR2_START;
+	}
+
+	/* Set common interrupt enable bits */
+	uint32_t cr1 = I2C_CR1_ERRIE | I2C_CR1_STOPIE | I2C_CR1_TCIE | I2C_CR1_NACKIE;
+
+#ifdef CONFIG_I2C_STM32_V2_DMA
+	dma_xfer_start(dev, msg);
+#else
+	/* If not using DMA, also enable RX and TX empty interrupts */
+	cr1 |= I2C_CR1_TXIE | I2C_CR1_RXIE;
+#endif
+
+	/* Commit configuration to I2C controller and start transfer */
+	LL_I2C_WriteReg(regs, CR2, cr2);
+
+	cr1 |= LL_I2C_ReadReg(regs, CR1);
+
+	/* Enable interrupts */
+	LL_I2C_WriteReg(regs, CR1, cr1);
+
+	/* Wait for IRQ to complete or timeout
+	 * Timeout scales with one millisecond for each byte to
+	 * transfer so that slave can do some clock stretching
+	 */
+	if (k_sem_take(&data->device_sync_sem, K_MSEC(msg->len + 10U)) != 0U) {
+		is_timeout = true;
+	}
+
+#ifdef CONFIG_I2C_STM32_V2_DMA
+	if ((data->current.msg->flags & I2C_MSG_READ) != 0) {
+		dma_stop(cfg->rx_dma.dev_dma, cfg->rx_dma.dma_channel);
+		LL_I2C_DisableDMAReq_RX(regs);
+	} else {
+		dma_stop(cfg->tx_dma.dev_dma, cfg->tx_dma.dma_channel);
+		LL_I2C_DisableDMAReq_TX(regs);
+	}
+#endif /* CONFIG_I2C_STM32_V2_DMA */
+
+	/* Check for transfer errors or timeout */
+	if (data->current.is_nack || data->current.is_arlo || is_timeout) {
+		LL_I2C_Disable(regs);
+		goto error;
+	}
+
+	if ((msg->flags & I2C_MSG_STOP) != 0U) {
+		/* Disable I2C if this was the last message and SMBus alert is not active */
+#if defined(CONFIG_I2C_TARGET)
+		data->master_active = false;
+		if (!data->slave_attached && !data->smbalert_active) {
+			LL_I2C_Disable(regs);
+		}
+#else
+		if (!data->smbalert_active) {
+			LL_I2C_Disable(regs);
+		}
+#endif
+	}
+#if defined(CONFIG_I2C_STM32_V2_DMA)
+	if (!stm32_buf_in_nocache((uintptr_t)msg->buf, msg->len) &&
+	    ((msg->flags & I2C_MSG_RW_MASK) == I2C_MSG_READ)) {
+		LOG_DBG("Rx buffer at %p (len %zu) is in cached memory; invalidating cache",
+			msg->buf, msg->len);
+		sys_cache_data_invd_range(msg->buf, msg->len);
+	}
+#endif /* CONFIG_I2C_STM32_V2_DMA */
+
+	return 0;
+
+error:
+	if (data->current.is_arlo) {
+		LOG_DBG("ARLO");
+		data->current.is_arlo = 0U;
+	}
+
+	if (data->current.is_nack) {
+		LOG_DBG("NACK");
+		data->current.is_nack = 0U;
+	}
+
+	if (data->current.is_err) {
+		LOG_DBG("ERR %d", data->current.is_err);
+		data->current.is_err = 0U;
+	}
+
+	if (is_timeout) {
+		LOG_DBG("TIMEOUT");
+	}
+
+	return -EIO;
+}
+
 #else /* !CONFIG_I2C_STM32_INTERRUPT */
 static inline int check_errors(const struct device *dev, const char *funcname)
 {
@@ -1251,6 +1486,11 @@ int i2c_stm32_transaction(const struct device *dev,
 			  struct i2c_msg msg, uint8_t *next_msg_flags,
 			  uint16_t periph)
 {
+	int ret = 0;
+
+#ifdef CONFIG_I2C_STM32_INTERRUPT
+	ret = stm32_i2c_irq_xfer(dev, &msg, next_msg_flags, periph);
+#else
 	/*
 	 * Perform a I2C transaction, while taking into account the STM32 I2C V2
 	 * peripheral has a limited maximum chunk size. Take appropriate action
@@ -1263,13 +1503,15 @@ int i2c_stm32_transaction(const struct device *dev,
 	 * which will make the combination of all chunks to look like one big
 	 * transaction on the wire.
 	 */
+	struct i2c_stm32_data *data = dev->data;
+	const struct i2c_stm32_config *cfg = dev->config;
+	I2C_TypeDef *i2c = cfg->i2c;
 	const uint32_t i2c_stm32_maxchunk = 255U;
 	const uint8_t saved_flags = msg.flags;
 	uint8_t combine_flags =
 		saved_flags & ~(I2C_MSG_STOP | I2C_MSG_RESTART);
 	uint8_t *flagsp = NULL;
 	uint32_t rest = msg.len;
-	int ret = 0;
 
 	do { /* do ... while to allow zero-length transactions */
 		if (msg.len > i2c_stm32_maxchunk) {
@@ -1293,11 +1535,6 @@ int i2c_stm32_transaction(const struct device *dev,
 		msg.len = rest;
 	} while (rest > 0U);
 
-#ifndef CONFIG_I2C_STM32_INTERRUPT
-	struct i2c_stm32_data *data = dev->data;
-	const struct i2c_stm32_config *cfg = dev->config;
-	I2C_TypeDef *i2c = cfg->i2c;
-
 	if (ret == -ETIMEDOUT) {
 		if (LL_I2C_IsEnabledReloadMode(i2c)) {
 			LL_I2C_DisableReloadMode(i2c);
@@ -1314,7 +1551,7 @@ int i2c_stm32_transaction(const struct device *dev,
 #endif
 		return -EIO;
 	}
-#endif /* !CONFIG_I2C_STM32_INTERRUPT */
+#endif /* CONFIG_I2C_STM32_INTERRUPT */
 
 	return ret;
 }

From 639bd9f938aafcb6cb10d2aad26d3c13eef82a65 Mon Sep 17 00:00:00 2001
From: Erik Andersson <erian747@gmail.com>
Date: Sun, 4 May 2025 22:25:08 +0200
Subject: [PATCH 3/7] drivers: i2c_stm32_v2: Remove obsolete functions

stm32_i2c_msg_read and stm32_i2c_msg_write
for interrupt mode is replaced by a common
function: stm32_i2c_irq_xfer

Signed-off-by: Erik Andersson <erian747@gmail.com>
---
 drivers/i2c/i2c_ll_stm32_v2.c | 147 +---------------------------------
 1 file changed, 4 insertions(+), 143 deletions(-)

diff --git a/drivers/i2c/i2c_ll_stm32_v2.c b/drivers/i2c/i2c_ll_stm32_v2.c
index dc895e925e94f..369d12c6ed640 100644
--- a/drivers/i2c/i2c_ll_stm32_v2.c
+++ b/drivers/i2c/i2c_ll_stm32_v2.c
@@ -276,17 +276,6 @@ static void i2c_stm32_disable_transfer_interrupts(const struct device *dev)
 	}
 }
 
-static void i2c_stm32_enable_transfer_interrupts(const struct device *dev)
-{
-	const struct i2c_stm32_config *cfg = dev->config;
-	I2C_TypeDef *i2c = cfg->i2c;
-
-	LL_I2C_EnableIT_STOP(i2c);
-	LL_I2C_EnableIT_NACK(i2c);
-	LL_I2C_EnableIT_TC(i2c);
-	LL_I2C_EnableIT_ERR(i2c);
-}
-
 static void i2c_stm32_master_mode_end(const struct device *dev)
 {
 	const struct i2c_stm32_config *cfg = dev->config;
@@ -413,7 +402,10 @@ static void i2c_stm32_slave_event(const struct device *dev)
 			}
 		}
 
-		i2c_stm32_enable_transfer_interrupts(dev);
+		LL_I2C_EnableIT_STOP(i2c);
+		LL_I2C_EnableIT_NACK(i2c);
+		LL_I2C_EnableIT_TC(i2c);
+		LL_I2C_EnableIT_ERR(i2c);
 	}
 }
 
@@ -706,137 +698,6 @@ int i2c_stm32_error(const struct device *dev)
 	return -EIO;
 }
 
-static int i2c_stm32_msg_write(const struct device *dev, struct i2c_msg *msg,
-			       uint8_t *next_msg_flags, uint16_t slave)
-{
-	const struct i2c_stm32_config *cfg = dev->config;
-	struct i2c_stm32_data *data = dev->data;
-	I2C_TypeDef *i2c = cfg->i2c;
-	bool is_timeout = false;
-
-	data->current.len = msg->len;
-	data->current.buf = msg->buf;
-	data->current.is_write = 1U;
-	data->current.is_nack = 0U;
-	data->current.is_err = 0U;
-	data->current.msg = msg;
-
-#if defined(CONFIG_I2C_STM32_V2_DMA)
-	if (!stm32_buf_in_nocache((uintptr_t)msg->buf, msg->len)) {
-		LOG_DBG("Tx buffer at %p (len %zu) is in cached memory; cleaning cache", msg->buf,
-			msg->len);
-		sys_cache_data_flush_range((void *)msg->buf, msg->len);
-	}
-#endif /* CONFIG_I2C_STM32_V2_DMA */
-
-	msg_init(dev, msg, next_msg_flags, slave, LL_I2C_REQUEST_WRITE);
-
-	i2c_stm32_enable_transfer_interrupts(dev);
-	LL_I2C_EnableIT_TX(i2c);
-
-	if (k_sem_take(&data->device_sync_sem,
-		       K_MSEC(I2C_STM32_TRANSFER_TIMEOUT_MSEC)) != 0) {
-		i2c_stm32_master_mode_end(dev);
-		k_sem_take(&data->device_sync_sem, K_FOREVER);
-		is_timeout = true;
-	}
-#ifdef CONFIG_I2C_STM32_V2_DMA
-	dma_finish(dev, msg);
-#endif
-
-	if (data->current.is_nack || data->current.is_err ||
-	    data->current.is_arlo || is_timeout) {
-		goto error;
-	}
-
-	return 0;
-error:
-	if (data->current.is_arlo) {
-		LOG_DBG("%s: ARLO %d", __func__,
-				    data->current.is_arlo);
-		data->current.is_arlo = 0U;
-	}
-
-	if (data->current.is_nack) {
-		LOG_DBG("%s: NACK", __func__);
-		data->current.is_nack = 0U;
-	}
-
-	if (data->current.is_err) {
-		LOG_DBG("%s: ERR %d", __func__,
-				    data->current.is_err);
-		data->current.is_err = 0U;
-	}
-
-	if (is_timeout) {
-		LOG_DBG("%s: TIMEOUT", __func__);
-	}
-
-	return -EIO;
-}
-
-static int i2c_stm32_msg_read(const struct device *dev, struct i2c_msg *msg,
-			      uint8_t *next_msg_flags, uint16_t slave)
-{
-	const struct i2c_stm32_config *cfg = dev->config;
-	struct i2c_stm32_data *data = dev->data;
-	I2C_TypeDef *i2c = cfg->i2c;
-	bool is_timeout = false;
-
-	data->current.len = msg->len;
-	data->current.buf = msg->buf;
-	data->current.is_write = 0U;
-	data->current.is_arlo = 0U;
-	data->current.is_err = 0U;
-	data->current.is_nack = 0U;
-	data->current.msg = msg;
-
-	msg_init(dev, msg, next_msg_flags, slave, LL_I2C_REQUEST_READ);
-
-	i2c_stm32_enable_transfer_interrupts(dev);
-	LL_I2C_EnableIT_RX(i2c);
-
-	if (k_sem_take(&data->device_sync_sem,
-		       K_MSEC(I2C_STM32_TRANSFER_TIMEOUT_MSEC)) != 0) {
-		i2c_stm32_master_mode_end(dev);
-		k_sem_take(&data->device_sync_sem, K_FOREVER);
-		is_timeout = true;
-	}
-#ifdef CONFIG_I2C_STM32_V2_DMA
-	dma_finish(dev, msg);
-#endif
-
-	if (data->current.is_nack || data->current.is_err ||
-	    data->current.is_arlo || is_timeout) {
-		goto error;
-	}
-
-	return 0;
-error:
-	if (data->current.is_arlo) {
-		LOG_DBG("%s: ARLO %d", __func__,
-				    data->current.is_arlo);
-		data->current.is_arlo = 0U;
-	}
-
-	if (data->current.is_nack) {
-		LOG_DBG("%s: NACK", __func__);
-		data->current.is_nack = 0U;
-	}
-
-	if (data->current.is_err) {
-		LOG_DBG("%s: ERR %d", __func__,
-				    data->current.is_err);
-		data->current.is_err = 0U;
-	}
-
-	if (is_timeout) {
-		LOG_DBG("%s: TIMEOUT", __func__);
-	}
-
-	return -EIO;
-}
-
 static int stm32_i2c_irq_xfer(const struct device *dev, struct i2c_msg *msg,
 			      uint8_t *next_msg_flags, uint16_t slave)
 {

From 46a8a749f994edbb52ae1f24cc63bf8159cf42f0 Mon Sep 17 00:00:00 2001
From: Erik Andersson <erian747@gmail.com>
Date: Sun, 4 May 2025 23:21:54 +0200
Subject: [PATCH 4/7] drivers: i2c_stm32_v2: DMA fixup

Adapt DMA implementation to match changes
introduced by new interrupt handler

Signed-off-by: Erik Andersson <erian747@gmail.com>
---
 drivers/i2c/i2c_ll_stm32_v2.c | 107 ++++++++++++++--------------------
 1 file changed, 43 insertions(+), 64 deletions(-)

diff --git a/drivers/i2c/i2c_ll_stm32_v2.c b/drivers/i2c/i2c_ll_stm32_v2.c
index 369d12c6ed640..c212e59bce5ca 100644
--- a/drivers/i2c/i2c_ll_stm32_v2.c
+++ b/drivers/i2c/i2c_ll_stm32_v2.c
@@ -210,53 +210,6 @@ static void dma_finish(const struct device *dev, struct i2c_msg *msg)
 
 #endif /* CONFIG_I2C_STM32_V2_DMA */
 
-static inline void msg_init(const struct device *dev, struct i2c_msg *msg,
-			    uint8_t *next_msg_flags, uint16_t slave,
-			    uint32_t transfer)
-{
-	const struct i2c_stm32_config *cfg = dev->config;
-	struct i2c_stm32_data *data = dev->data;
-	I2C_TypeDef *i2c = cfg->i2c;
-
-	if (LL_I2C_IsEnabledReloadMode(i2c)) {
-		LL_I2C_SetTransferSize(i2c, msg->len);
-	} else {
-		if (I2C_ADDR_10_BITS & data->dev_config) {
-			LL_I2C_SetMasterAddressingMode(i2c,
-					LL_I2C_ADDRESSING_MODE_10BIT);
-			LL_I2C_SetSlaveAddr(i2c, (uint32_t) slave);
-		} else {
-			LL_I2C_SetMasterAddressingMode(i2c,
-				LL_I2C_ADDRESSING_MODE_7BIT);
-			LL_I2C_SetSlaveAddr(i2c, (uint32_t) slave << 1);
-		}
-
-		if (!(msg->flags & I2C_MSG_STOP) && next_msg_flags &&
-		    !(*next_msg_flags & I2C_MSG_RESTART)) {
-			LL_I2C_EnableReloadMode(i2c);
-		} else {
-			LL_I2C_DisableReloadMode(i2c);
-		}
-		LL_I2C_DisableAutoEndMode(i2c);
-		LL_I2C_SetTransferRequest(i2c, transfer);
-		LL_I2C_SetTransferSize(i2c, msg->len);
-
-#if defined(CONFIG_I2C_TARGET)
-		data->master_active = true;
-#endif
-
-#ifdef CONFIG_I2C_STM32_V2_DMA
-		if (msg->len) {
-			dma_xfer_start(dev, msg);
-		}
-#endif /* CONFIG_I2C_STM32_V2_DMA */
-
-		LL_I2C_Enable(i2c);
-
-		LL_I2C_GenerateStartCondition(i2c);
-	}
-}
-
 #ifdef CONFIG_I2C_STM32_INTERRUPT
 
 static void i2c_stm32_disable_transfer_interrupts(const struct device *dev)
@@ -828,15 +781,9 @@ static int stm32_i2c_irq_xfer(const struct device *dev, struct i2c_msg *msg,
 	}
 
 #ifdef CONFIG_I2C_STM32_V2_DMA
-	if ((data->current.msg->flags & I2C_MSG_READ) != 0) {
-		dma_stop(cfg->rx_dma.dev_dma, cfg->rx_dma.dma_channel);
-		LL_I2C_DisableDMAReq_RX(regs);
-	} else {
-		dma_stop(cfg->tx_dma.dev_dma, cfg->tx_dma.dma_channel);
-		LL_I2C_DisableDMAReq_TX(regs);
-	}
-#endif /* CONFIG_I2C_STM32_V2_DMA */
-
+	/* Stop DMA and invalidate cache if needed */
+	dma_finish(dev, msg);
+#endif
 	/* Check for transfer errors or timeout */
 	if (data->current.is_nack || data->current.is_arlo || is_timeout) {
 		LL_I2C_Disable(regs);
@@ -856,14 +803,6 @@ static int stm32_i2c_irq_xfer(const struct device *dev, struct i2c_msg *msg,
 		}
 #endif
 	}
-#if defined(CONFIG_I2C_STM32_V2_DMA)
-	if (!stm32_buf_in_nocache((uintptr_t)msg->buf, msg->len) &&
-	    ((msg->flags & I2C_MSG_RW_MASK) == I2C_MSG_READ)) {
-		LOG_DBG("Rx buffer at %p (len %zu) is in cached memory; invalidating cache",
-			msg->buf, msg->len);
-		sys_cache_data_invd_range(msg->buf, msg->len);
-	}
-#endif /* CONFIG_I2C_STM32_V2_DMA */
 
 	return 0;
 
@@ -928,6 +867,46 @@ static inline int check_errors(const struct device *dev, const char *funcname)
 	return -EIO;
 }
 
+static inline void msg_init(const struct device *dev, struct i2c_msg *msg,
+			    uint8_t *next_msg_flags, uint16_t slave,
+			    uint32_t transfer)
+{
+	const struct i2c_stm32_config *cfg = dev->config;
+	struct i2c_stm32_data *data = dev->data;
+	I2C_TypeDef *i2c = cfg->i2c;
+
+	if (LL_I2C_IsEnabledReloadMode(i2c)) {
+		LL_I2C_SetTransferSize(i2c, msg->len);
+	} else {
+		if (I2C_ADDR_10_BITS & data->dev_config) {
+			LL_I2C_SetMasterAddressingMode(i2c,
+					LL_I2C_ADDRESSING_MODE_10BIT);
+			LL_I2C_SetSlaveAddr(i2c, (uint32_t) slave);
+		} else {
+			LL_I2C_SetMasterAddressingMode(i2c,
+				LL_I2C_ADDRESSING_MODE_7BIT);
+			LL_I2C_SetSlaveAddr(i2c, (uint32_t) slave << 1);
+		}
+
+		if (!(msg->flags & I2C_MSG_STOP) && next_msg_flags &&
+		    !(*next_msg_flags & I2C_MSG_RESTART)) {
+			LL_I2C_EnableReloadMode(i2c);
+		} else {
+			LL_I2C_DisableReloadMode(i2c);
+		}
+		LL_I2C_DisableAutoEndMode(i2c);
+		LL_I2C_SetTransferRequest(i2c, transfer);
+		LL_I2C_SetTransferSize(i2c, msg->len);
+
+#if defined(CONFIG_I2C_TARGET)
+		data->master_active = true;
+#endif
+		LL_I2C_Enable(i2c);
+
+		LL_I2C_GenerateStartCondition(i2c);
+	}
+}
+
 static inline int msg_done(const struct device *dev,
 			   unsigned int current_msg_flags)
 {

From 1503a17b836b94905e0482329b84f5b292494cb7 Mon Sep 17 00:00:00 2001
From: Erik Andersson <erian747@gmail.com>
Date: Sun, 4 May 2025 23:30:32 +0200
Subject: [PATCH 5/7] drivers: i2c_stm32_v2: Bus error errata fix

Don't abort transaction on bus error in master mode
according to errata sheet

Signed-off-by: Erik Andersson <erian747@gmail.com>
---
 drivers/i2c/i2c_ll_stm32_v2.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/drivers/i2c/i2c_ll_stm32_v2.c b/drivers/i2c/i2c_ll_stm32_v2.c
index c212e59bce5ca..d1337a29e2c58 100644
--- a/drivers/i2c/i2c_ll_stm32_v2.c
+++ b/drivers/i2c/i2c_ll_stm32_v2.c
@@ -629,10 +629,14 @@ int i2c_stm32_error(const struct device *dev)
 		goto end;
 	}
 
+	/* Don't end a transaction on bus error in master mode
+	 * as errata sheet says that spurious false detections
+	 * of BERR can happen which shall be ignored.
+	 * If a real Bus Error occurs, transaction will time out.
+	 */
 	if (LL_I2C_IsActiveFlag_BERR(i2c)) {
 		LL_I2C_ClearFlag_BERR(i2c);
 		data->current.is_err = 1U;
-		goto end;
 	}
 
 #if defined(CONFIG_SMBUS_STM32_SMBALERT)

From 0dd46c7314c9d23c9a9dc644be2315914de34161 Mon Sep 17 00:00:00 2001
From: Erik Andersson <erian747@gmail.com>
Date: Sun, 4 May 2025 23:35:47 +0200
Subject: [PATCH 6/7] drivers: i2c_stm32_v2: Refactor end of master transfer

The stm32_i2c_master_mode_end function can be
replaced with a simple irq disable and giving to
the device sync semaphore

Signed-off-by: Erik Andersson <erian747@gmail.com>
---
 drivers/i2c/i2c_ll_stm32_v2.c | 150 +++++++++++++++-------------------
 1 file changed, 67 insertions(+), 83 deletions(-)

diff --git a/drivers/i2c/i2c_ll_stm32_v2.c b/drivers/i2c/i2c_ll_stm32_v2.c
index d1337a29e2c58..d56e6bde62ce6 100644
--- a/drivers/i2c/i2c_ll_stm32_v2.c
+++ b/drivers/i2c/i2c_ll_stm32_v2.c
@@ -229,32 +229,6 @@ static void i2c_stm32_disable_transfer_interrupts(const struct device *dev)
 	}
 }
 
-static void i2c_stm32_master_mode_end(const struct device *dev)
-{
-	const struct i2c_stm32_config *cfg = dev->config;
-	struct i2c_stm32_data *data = dev->data;
-	I2C_TypeDef *i2c = cfg->i2c;
-
-	i2c_stm32_disable_transfer_interrupts(dev);
-
-	if (LL_I2C_IsEnabledReloadMode(i2c)) {
-		LL_I2C_DisableReloadMode(i2c);
-	}
-
-#if defined(CONFIG_I2C_TARGET)
-	data->master_active = false;
-	if (!data->slave_attached && !data->smbalert_active) {
-		LL_I2C_Disable(i2c);
-	}
-#else
-	if (!data->smbalert_active) {
-		LL_I2C_Disable(i2c);
-	}
-#endif
-
-	k_sem_give(&data->device_sync_sem);
-}
-
 #if defined(CONFIG_I2C_TARGET)
 static void i2c_stm32_slave_event(const struct device *dev)
 {
@@ -651,17 +625,80 @@ int i2c_stm32_error(const struct device *dev)
 
 	return 0;
 end:
-	i2c_stm32_master_mode_end(dev);
+	i2c_stm32_disable_transfer_interrupts(dev);
+	/* Wakeup thread */
+	k_sem_give(&data->device_sync_sem);
 	return -EIO;
 }
 
+static int stm32_i2c_irq_msg_finish(const struct device *dev, struct i2c_msg *msg)
+{
+	struct i2c_stm32_data *data = dev->data;
+	const struct i2c_stm32_config *cfg = dev->config;
+	bool keep_enabled = (msg->flags & I2C_MSG_STOP) == 0U;
+	int ret;
+
+	/* Wait for IRQ to complete or timeout
+	 * Timeout scales with one millisecond for each byte to
+	 * transfer so that slave can do some clock stretching
+	 */
+	ret = k_sem_take(&data->device_sync_sem, K_MSEC(msg->len + 10U));
+
+#ifdef CONFIG_I2C_STM32_V2_DMA
+	/* Stop DMA and invalidate cache if needed */
+	dma_finish(dev, msg);
+#endif
+
+	/* Check for transfer errors or timeout */
+	if (data->current.is_nack || data->current.is_arlo || (ret != 0)) {
+
+		if (data->current.is_arlo) {
+			LOG_DBG("ARLO");
+		}
+
+		if (data->current.is_nack) {
+			LOG_DBG("NACK");
+		}
+
+		if (data->current.is_err) {
+			LOG_DBG("ERR %d", data->current.is_err);
+		}
+
+		if (ret != 0) {
+			LOG_DBG("TIMEOUT");
+		}
+		ret = -EIO;
+	}
+
+#if defined(CONFIG_I2C_TARGET)
+	if (!keep_enabled || (ret != 0)) {
+		data->master_active = false;
+	}
+	/* Don't disable I2C if a slave is attached */
+	if (data->slave_attached) {
+		keep_enabled = true;
+	}
+#endif
+
+	/* Don't disable I2C if SMBus Alert is active */
+	if (data->smbalert_active) {
+		keep_enabled = true;
+	}
+
+	/* If I2C no longer need to be enabled or on error */
+	if (!keep_enabled || (ret != 0)) {
+		LL_I2C_Disable(cfg->i2c);
+	}
+
+	return ret;
+}
+
 static int stm32_i2c_irq_xfer(const struct device *dev, struct i2c_msg *msg,
 			      uint8_t *next_msg_flags, uint16_t slave)
 {
 	const struct i2c_stm32_config *cfg = dev->config;
 	struct i2c_stm32_data *data = dev->data;
 	I2C_TypeDef *regs = cfg->i2c;
-	bool is_timeout = false;
 
 	data->current.len = msg->len;
 	data->current.buf = msg->buf;
@@ -776,61 +813,8 @@ static int stm32_i2c_irq_xfer(const struct device *dev, struct i2c_msg *msg,
 	/* Enable interrupts */
 	LL_I2C_WriteReg(regs, CR1, cr1);
 
-	/* Wait for IRQ to complete or timeout
-	 * Timeout scales with one millisecond for each byte to
-	 * transfer so that slave can do some clock stretching
-	 */
-	if (k_sem_take(&data->device_sync_sem, K_MSEC(msg->len + 10U)) != 0U) {
-		is_timeout = true;
-	}
-
-#ifdef CONFIG_I2C_STM32_V2_DMA
-	/* Stop DMA and invalidate cache if needed */
-	dma_finish(dev, msg);
-#endif
-	/* Check for transfer errors or timeout */
-	if (data->current.is_nack || data->current.is_arlo || is_timeout) {
-		LL_I2C_Disable(regs);
-		goto error;
-	}
-
-	if ((msg->flags & I2C_MSG_STOP) != 0U) {
-		/* Disable I2C if this was the last message and SMBus alert is not active */
-#if defined(CONFIG_I2C_TARGET)
-		data->master_active = false;
-		if (!data->slave_attached && !data->smbalert_active) {
-			LL_I2C_Disable(regs);
-		}
-#else
-		if (!data->smbalert_active) {
-			LL_I2C_Disable(regs);
-		}
-#endif
-	}
-
-	return 0;
-
-error:
-	if (data->current.is_arlo) {
-		LOG_DBG("ARLO");
-		data->current.is_arlo = 0U;
-	}
-
-	if (data->current.is_nack) {
-		LOG_DBG("NACK");
-		data->current.is_nack = 0U;
-	}
-
-	if (data->current.is_err) {
-		LOG_DBG("ERR %d", data->current.is_err);
-		data->current.is_err = 0U;
-	}
-
-	if (is_timeout) {
-		LOG_DBG("TIMEOUT");
-	}
-
-	return -EIO;
+	/* Wait for transfer to finish */
+	return stm32_i2c_irq_msg_finish(dev, msg);
 }
 
 #else /* !CONFIG_I2C_STM32_INTERRUPT */

From 0c16867685d27dbd08a59024e1b87c65ffa07dbb Mon Sep 17 00:00:00 2001
From: Erik Andersson <erian747@gmail.com>
Date: Thu, 3 Jul 2025 08:19:36 +0200
Subject: [PATCH 7/7] drivers: i2c_stm32_v2: Abort on DMA error

If configuration of DMA is unsuccessful then
abort transaction and return with an error code

Signed-off-by: Erik Andersson <erian747@gmail.com>
---
 drivers/i2c/i2c_ll_stm32_v2.c | 29 ++++++++++++++++++-----------
 1 file changed, 18 insertions(+), 11 deletions(-)

diff --git a/drivers/i2c/i2c_ll_stm32_v2.c b/drivers/i2c/i2c_ll_stm32_v2.c
index d56e6bde62ce6..28d5e9459ac1c 100644
--- a/drivers/i2c/i2c_ll_stm32_v2.c
+++ b/drivers/i2c/i2c_ll_stm32_v2.c
@@ -151,11 +151,12 @@ static int configure_dma(struct stream const *dma, struct dma_config *dma_cfg,
 	return 0;
 }
 
-static void dma_xfer_start(const struct device *dev, struct i2c_msg *msg)
+static int dma_xfer_start(const struct device *dev, struct i2c_msg *msg)
 {
 	const struct i2c_stm32_config *cfg = dev->config;
 	struct i2c_stm32_data *data = dev->data;
 	I2C_TypeDef *i2c = cfg->i2c;
+	int ret = 0;
 
 	if ((msg->flags & I2C_MSG_READ) != 0U) {
 		/* Configure RX DMA */
@@ -166,10 +167,10 @@ static void dma_xfer_start(const struct device *dev, struct i2c_msg *msg)
 		data->dma_blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_INCREMENT;
 		data->dma_blk_cfg.block_size = data->current.len;
 
-		if (configure_dma(&cfg->rx_dma, &data->dma_rx_cfg,
-					&data->dma_blk_cfg) != 0) {
-			LOG_ERR("Problem setting up RX DMA");
-			return;
+		ret = configure_dma(&cfg->rx_dma, &data->dma_rx_cfg, &data->dma_blk_cfg);
+
+		if (ret != 0) {
+			return ret;
 		}
 		LL_I2C_EnableDMAReq_RX(i2c);
 	} else {
@@ -182,14 +183,14 @@ static void dma_xfer_start(const struct device *dev, struct i2c_msg *msg)
 			data->dma_blk_cfg.dest_addr_adj = DMA_ADDR_ADJ_NO_CHANGE;
 			data->dma_blk_cfg.block_size = data->current.len;
 
-			if (configure_dma(&cfg->tx_dma, &data->dma_tx_cfg,
-						&data->dma_blk_cfg) != 0) {
-				LOG_ERR("Problem setting up TX DMA");
-				return;
+			ret = configure_dma(&cfg->tx_dma, &data->dma_tx_cfg, &data->dma_blk_cfg);
+			if (ret != 0) {
+				return ret;
 			}
 			LL_I2C_EnableDMAReq_TX(i2c);
 		}
 	}
+	return ret;
 }
 
 static void dma_finish(const struct device *dev, struct i2c_msg *msg)
@@ -799,11 +800,17 @@ static int stm32_i2c_irq_xfer(const struct device *dev, struct i2c_msg *msg,
 	uint32_t cr1 = I2C_CR1_ERRIE | I2C_CR1_STOPIE | I2C_CR1_TCIE | I2C_CR1_NACKIE;
 
 #ifdef CONFIG_I2C_STM32_V2_DMA
-	dma_xfer_start(dev, msg);
+	if (dma_xfer_start(dev, msg) != 0) {
+		LL_I2C_Disable(regs);
+#if defined(CONFIG_I2C_TARGET)
+		data->master_active = false;
+#endif
+		return -EIO;
+	}
 #else
 	/* If not using DMA, also enable RX and TX empty interrupts */
 	cr1 |= I2C_CR1_TXIE | I2C_CR1_RXIE;
-#endif
+#endif /* CONFIG_I2C_STM32_V2_DMA */
 
 	/* Commit configuration to I2C controller and start transfer */
 	LL_I2C_WriteReg(regs, CR2, cr2);
